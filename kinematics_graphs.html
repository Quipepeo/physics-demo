<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <title>Pierre Marie Curie - Physics 9 - Prof. Telson</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
      text-align: center;
    }
    h1 { margin-bottom: 4px; }
    h2 { margin-top: 0; color: #555; }
    #controls {
      display: inline-flex;
      gap: 20px;
      margin: 20px 0;
      align-items: center;
    }
    #controls label {
      display: flex;
      flex-direction: column;
      font-weight: bold;
      font-size: 14px;
    }
    #controls input {
      width: 80px;
      padding: 4px;
      text-align: right;
    }
    #exportBtn {
      padding: 6px 12px;
      font-size: 14px;
      cursor: pointer;
    }
    #charts {
      display: flex;
      gap: 20px;
      justify-content: center;
      margin-top: 20px;
    }
    .chart-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .chart-wrapper h3 {
      margin-bottom: 8px;
      font-size: 16px;
    }
    svg {
      border: 1px solid #ccc;
      background: #fafafa;
    }
    .line {
      fill: none;
      stroke-width: 2px;
    }
    .dial {
      fill: red;
      cursor: ns-resize;
    }
    .grid line {
      stroke: #ddd;
    }
    .grid path {
      display: none;
    }
    .axis path,
    .axis line {
      stroke: #333;
    }
    .axis text {
      font-size: 12px;
    }
  </style>
</head>
<body>

  <h1>Pierre Marie Curie - Physics 9 - Prof. Telson</h1>
  <h2>Kinematics Simulator</h2>

  <div id="controls">
    <label>
      Δt (s)
      <input type="number" id="dt" value="0.1" min="0.01" step="0.01"/>
    </label>
    <label>
      Initial Position x₀ (m)
      <input type="number" id="x0" value="0" step="1"/>
    </label>
    <label>
      Initial Velocity v₀ (m/s)
      <input type="number" id="v0" value="0" step="1"/>
    </label>
    <button id="exportBtn">Export CSV</button>
  </div>

  <div id="charts">
    <div class="chart-wrapper">
      <h3>Position vs. Time</h3>
      <div id="pos-chart"></div>
    </div>
    <div class="chart-wrapper">
      <h3>Velocity vs. Time</h3>
      <div id="vel-chart"></div>
    </div>
    <div class="chart-wrapper">
      <h3>Acceleration vs. Time</h3>
      <div id="acc-chart"></div>
    </div>
  </div>

  <script>
  document.addEventListener('DOMContentLoaded', () => {
    // Configuration
    const duration = 5;              // seconds
    const margin   = { top: 20, right: 20, bottom: 30, left: 50 };
    const width    = 300 - margin.left - margin.right;
    const height   = 250 - margin.top  - margin.bottom;

    // DOM elements
    const dtInput   = document.getElementById('dt');
    const x0Input   = document.getElementById('x0');
    const v0Input   = document.getElementById('v0');
    const exportBtn = document.getElementById('exportBtn');

    // Initial acceleration at integer seconds: a(t) = 6t − 6
    let accData = d3.range(0, duration + 1).map(t => ({
      t, a: 6 * t - 6
    }));

    // Create SVG container + groups for each chart
    function makeSvg(containerId) {
      return d3.select(containerId)
        .append('svg')
          .attr('width',  width + margin.left + margin.right)
          .attr('height', height + margin.top  + margin.bottom)
        .append('g')
          .attr('transform', `translate(${margin.left},${margin.top})`);
    }

    const svgPos = makeSvg('#pos-chart');
    const svgVel = makeSvg('#vel-chart');
    const svgAcc = makeSvg('#acc-chart');

    // Scales (x shared)
    const xScale = d3.scaleLinear()
      .domain([0, duration])
      .range([0, width]);

    // Y-scales: fixed for pos/vel, dynamic for acc
    const yScalePos = d3.scaleLinear()
      .domain([-40, 40])
      .range([height, 0]);

    const yScaleVel = d3.scaleLinear()
      .domain([-40, 40])
      .range([height, 0]);

    let yScaleAcc = d3.scaleLinear()
      .domain(d3.extent(accData, d => d.a)).nice()
      .range([height, 0]);

    // Line generators
    const linePos = d3.line()
      .x(d => xScale(d.t))
      .y(d => yScalePos(d.x));

    const lineVel = d3.line()
      .x(d => xScale(d.t))
      .y(d => yScaleVel(d.v));

    const lineAcc = d3.line()
      .x(d => xScale(d.t))
      .y(d => yScaleAcc(d.a));

    // Draw static grid + axes groups
    function setupChart(svg, xS, yS, yLabel) {
      // X grid lines
      svg.append('g')
        .attr('class', 'grid x-grid')
        .attr('transform', `translate(0,${height})`);

      // Y grid lines
      svg.append('g')
        .attr('class', 'grid y-grid');

      // X axis
      svg.append('g')
        .attr('class', 'axis x-axis')
        .attr('transform', `translate(0,${height})`);

      // Y axis
      svg.append('g')
        .attr('class', 'axis y-axis')
        .append('text')
          .attr('transform', 'rotate(-90)')
          .attr('y', 12)
          .attr('dy', '-3.5em')
          .attr('fill', '#000')
          .attr('text-anchor', 'end')
          .text(yLabel);
    }

    setupChart(svgPos, xScale, yScalePos, 'Position (m)');
    setupChart(svgVel, xScale, yScaleVel, 'Velocity (m/s)');
    setupChart(svgAcc, xScale, yScaleAcc, 'Acceleration (m/s²)');

    // Add initial lines & (acc) dials
    const pathPos = svgPos.append('path').attr('class','line').attr('stroke','blue');
    const pathVel = svgVel.append('path').attr('class','line').attr('stroke','green');
    const pathAcc = svgAcc.append('path').attr('class','line').attr('stroke','red');

    const drag = d3.drag()
      .on('drag', (event, d) => {
        // clamp, invert, round
        const newA = Math.round(
          yScaleAcc.invert(
            Math.max(0, Math.min(height, event.y))
          )
        );
        d.a = newA;
        d3.select(event.sourceEvent.target)
          .attr('cy', yScaleAcc(d.a));
        updateAll();
      });

    svgAcc.selectAll('.dial')
      .data(accData)
      .enter()
      .append('circle')
        .attr('class','dial')
        .attr('r',6)
        .attr('cx', d => xScale(d.t))
        .attr('cy', d => yScaleAcc(d.a))
        .call(drag);

    // Compute (t, x, v, a) arrays and redraw everything
    let lastData = [];

    function updateAll() {
      const dt = +dtInput.value;
      const x0 = +x0Input.value;
      const v0 = +v0Input.value;

      // 1) Sample times
      const tVals = [];
      for (let t = 0; t <= duration + 1e-9; t += dt) {
        tVals.push(+t.toFixed(6));
      }

      // 2) Interpolate acceleration a(t) on tVals
      const aVals = tVals.map(t => {
        const i = Math.floor(t);
        const frac = t - i;
        const a0 = accData[i]?.a ?? accData[accData.length-1].a;
        const a1 = accData[i+1]?.a ?? a0;
        return a0 + (a1 - a0) * frac;
      });

      // 3) Integrate to get v & x
      const vVals = [v0];
      const xVals = [x0];
      for (let i = 1; i < tVals.length; i++) {
        vVals.push(vVals[i-1] + aVals[i-1] * dt);
        xVals.push(
          xVals[i-1] +
          vVals[i-1] * dt +
          0.5 * aVals[i-1] * dt * dt
        );
      }

      // 4) Build unified data for CSV
      lastData = tVals.map((t,i) => ({
        t: tVals[i],
        x: xVals[i],
        v: vVals[i],
        a: aVals[i]
      }));

      // 5) Update Y-domain for acc
      yScaleAcc.domain(d3.extent(accData, d => d.a)).nice();

      // 6) Update grids & axes for each chart
      const xAxisGrid = d3.axisBottom(xScale)
        .tickValues(tVals)
        .tickSize(-height)
        .tickFormat('');
      const yGridPos = d3.axisLeft(yScalePos)
        .ticks(8)
        .tickSize(-width)
        .tickFormat('');
      const yGridVel = d3.axisLeft(yScaleVel)
        .ticks(8)
        .tickSize(-width)
        .tickFormat('');
      const yGridAcc = d3.axisLeft(yScaleAcc)
        .ticks(8)
        .tickSize(-width)
        .tickFormat('');

      svgPos.select('.x-grid').call(xAxisGrid);
      svgPos.select('.y-grid').call(yGridPos);
      svgVel.select('.x-grid').call(xAxisGrid);
      svgVel.select('.y-grid').call(yGridVel);
      svgAcc.select('.x-grid').call(xAxisGrid);
      svgAcc.select('.y-grid').call(yGridAcc);

      const xAxis = d3.axisBottom(xScale)
        .tickValues(tVals)
        .tickFormat(t => +t.toFixed(2));
      const yAxisPos = d3.axisLeft(yScalePos).ticks(8);
      const yAxisVel = d3.axisLeft(yScaleVel).ticks(8);
      const yAxisAcc = d3.axisLeft(yScaleAcc).ticks(8);

      svgPos.select('.x-axis')
        .call(xAxis)
        .select('text').text('Time (s)');
      svgPos.select('.y-axis').call(yAxisPos);

      svgVel.select('.x-axis')
        .call(xAxis)
        .select('text').text('Time (s)');
      svgVel.select('.y-axis').call(yAxisVel);

      svgAcc.select('.x-axis')
        .call(xAxis)
        .select('text').text('Time (s)');
      svgAcc.select('.y-axis').call(yAxisAcc);

      // 7) Redraw lines
      pathPos
        .datum(lastData)
        .attr('d', linePos);
      pathVel
        .datum(lastData)
        .attr('d', lineVel);
      pathAcc
        .datum(accData)
        .attr('d', lineAcc);

      // 8) Move acc dials
      svgAcc.selectAll('.dial')
        .attr('cy', d => yScaleAcc(d.a));
    }

    // CSV Export
    function exportCSV() {
      const header = 't,x,v,a\n';
      const rows = lastData.map(d => `${d.t},${d.x},${d.v},${d.a}`).join('\n');
      const csv  = header + rows;
      const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
      const url  = URL.createObjectURL(blob);
      const a    = document.createElement('a');
      a.href     = url;
      a.download = 'kinematics.csv';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    // Wire events
    dtInput.addEventListener('input', updateAll);
    x0Input.addEventListener('input', updateAll);
    v0Input.addEventListener('input', updateAll);
    exportBtn.addEventListener('click', exportCSV);

    // Initial draw
    updateAll();
  });
  </script>
</body>
</html>
