<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Pierre Marie Curie Physics09 Class – Complex Velocity and Displacement</title>
<style>
  body { font-family: Arial, sans-serif; padding: 20px; text-align: center; }
  h2 { margin-bottom: 18px; }
  .row { display: flex; justify-content: center; gap: 28px; flex-wrap: wrap; margin-bottom: 18px; }
  .panel { display: flex; flex-direction: column; align-items: center; }
  .classLabel { font-weight: bold; font-size: 14px; color: #444; margin: 6px 0 8px; }
  .label { font-weight: bold; margin-bottom: 8px; }
  canvas { background: #fafafa; border: 1px solid #ccc; }
  .readout { margin-top: 6px; min-height: 1.2em; font-size: 14px; color: #333; }
  button { margin-top: 10px; padding: 8px 16px; font-size: 14px; cursor: pointer; }
  .legend { margin-top: 6px; font-size: 13px; color: #333; }
  .legend span { display: inline-flex; align-items: center; margin: 0 8px; }
  .swatch { display: inline-block; width: 14px; height: 14px; margin-right: 6px; border: 1px solid #999; }
</style>
</head>
<body>

<h2>Pierre Marie Curie Physics09 Class – Complex Velocity and Displacement</h2>

<div class="row">
  <div class="panel">
    <div class="classLabel">Pierre Marie Curie Physics09 Class</div>
    <div class="label">Plot 1: Velocity vs. Time (animated, full history)</div>
    <canvas id="velCanvas" width="900" height="380"></canvas>
    <div class="readout" id="velReadout"></div>
    <button id="startAreas">Show Displacement Areas Plot</button>
  </div>
</div>

<div class="row">
  <div class="panel">
    <div class="classLabel">Pierre Marie Curie Physics09 Class</div>
    <div class="label">Plot 2: Displacement as signed areas under v(t)</div>
    <canvas id="areaCanvas" width="900" height="380"></canvas>
    <div class="legend">
      <span><i class="swatch" style="background:#ffc107"></i> 0–2 s (v = +5)</span>
      <span><i class="swatch" style="background:#90caf9"></i> 2–4 s (5 → 0)</span>
      <span><i class="swatch" style="background:#ef9a9a"></i> 4–8 s (0 → −3)</span>
      <span><i class="swatch" style="background:#a5d6a7"></i> t = 8 s (jump −3 → +2)</span>
      <span><i class="swatch" style="background:#ffe082"></i> 8–11 s (2 → 4)</span>
    </div>
    <div class="readout" id="areaReadout">Waiting to start…</div>
  </div>
</div>

<script>
const start1 = performance.now();

function animateVelocity() {
  const now = performance.now();
  const elapsed = (now - start1) / 1000;
  const t = Math.min(elapsed, tMax);

  const f = drawAxes(vctx, velCanvas.width, velCanvas.height);

  // Draw full history up to current t
  vctx.lineWidth = 3;
  vctx.strokeStyle = '#1976d2';
  vctx.beginPath();
  vctx.moveTo(tToX(f.x0, f.x1, 0), vToY(f.y0, f.y1, velocityAt(0)));

  for (const s of segments) {
    if (s.type === 'jump') {
      if (t >= s.t0) {
        vctx.stroke();
        const xJ = tToX(f.x0, f.x1, s.t0);
        const yB = vToY(f.y0, f.y1, s.v0);
        const yA = vToY(f.y0, f.y1, s.v1);
        vctx.setLineDash([3,3]);
        vctx.beginPath();
        vctx.moveTo(xJ, yB);
        vctx.lineTo(xJ, yA);
        vctx.strokeStyle = '#888';
        vctx.lineWidth = 2;
        vctx.stroke();
        vctx.setLineDash([]);
        vctx.beginPath();
        vctx.strokeStyle = '#1976d2';
        vctx.lineWidth = 3;
        vctx.moveTo(xJ, yA);
      }
      continue;
    }
    const segEnd = Math.min(s.t1, t);
    if (segEnd > s.t0) {
      const x0 = tToX(f.x0, f.x1, s.t0);
      const y0v = vToY(f.y0, f.y1, s.v0);
      const xE = tToX(f.x0, f.x1, segEnd);
      const vEnd = s.type === 'const'
        ? s.v0
        : s.v0 + (s.v1 - s.v0) * ((segEnd - s.t0) / (s.t1 - s.t0));
      const yEv = vToY(f.y0, f.y1, vEnd);
      vctx.lineTo(x0, y0v);
      vctx.lineTo(xE, yEv);
    }
  }
  vctx.stroke();

  // Time cursor
  const xNow = tToX(f.x0, f.x1, t);
  vctx.beginPath();
  vctx.moveTo(xNow, f.y0);
  vctx.lineTo(xNow, f.y1);
  vctx.strokeStyle = 'rgba(0,0,0,0.2)';
  vctx.lineWidth = 2;
  vctx.stroke();

  velReadout.textContent = `t = ${t.toFixed(2)} s, v(t) = ${velocityAt(t).toFixed(2)} m/s`;

  if (elapsed < tMax) requestAnimationFrame(animateVelocity);
}
animateVelocity();

function signedAreaOfSegmentUpTo(s, tEnd) {
  const start = s.t0;
  const end = Math.min(s.t1, tEnd);
  if (end <= start) return 0;
  if (s.type === 'const') {
    return s.v0 * (end - start);
  } else if (s.type === 'lin') {
    const vStart = s.v0;
    const vEnd = s.v0 + (s.v1 - s.v0) * ((end - start) / (s.t1 - s.t0));
    const vAvg = 0.5 * (vStart + vEnd);
    return vAvg * (end - start);
  }
  return 0;
}

function cumulativeDisplacement(t) {
  return segments.reduce((sum, s) => sum + signedAreaOfSegmentUpTo(s, t), 0);
}

function animateAreas() {
  const start2 = performance.now();
  function frame() {
    const now = performance.now();
    const elapsed = (now - start2) / 1000;
    const t = Math.min(elapsed, tMax);

    const f = drawAxes(actx, areaCanvas.width, areaCanvas.height);

    // Shade each segment's area
    for (const s of segments) {
      if (s.type === 'jump') {
        if (t >= s.t0) {
          const xJ = tToX(f.x0, f.x1, s.t0);
          const yB = vToY(f.y0, f.y1, s.v0);
          const yA = vToY(f.y0, f.y1, s.v1);
          actx.setLineDash([3,3]);
          actx.strokeStyle = s.color;
          actx.beginPath();
          actx.moveTo(xJ, yB); actx.lineTo(xJ, yA); actx.stroke();
          actx.setLineDash([]);
        }
        continue;
      }
      const end = Math.min(s.t1, t);
      if (end <= s.t0) continue;
      const x0 = tToX(f.x0, f.x1, s.t0);
      const xE = tToX(f.x0, f.x1, end);
      const y0v = vToY(f.y0, f.y1, s.v0);
      const vEnd = s.type === 'const'
        ? s.v0
        : s.v0 + (s.v1 - s.v0) * ((end - s.t0) / (s.t1 - s.t0));
      const yEv = vToY(f.y0, f.y1, vEnd);
      const yZero = vToY(f.y0, f.y1, 0);

      actx.beginPath();
      actx.moveTo(x0, yZero);
      actx.lineTo(xE, yZero);
      actx.lineTo(xE, yEv);
      actx.lineTo(x0, y0v);
      actx.closePath();

      let fill = s.color;
      if (s.color === '#ffc107') fill = 'rgba(255,193,7,0.35)';
      if (s.color === '#90caf9') fill = 'rgba(144,202,249,0.35)';
      if (s.color === '#ef9a9a') fill = 'rgba(239,154,154,0.35)';
      if (s.color === '#a5d6a7') fill = 'rgba(165,214,167,0.35)';
      if (s.color === '#ffe082') fill = 'rgba(255,224,130,0.35)';
      actx.fillStyle = fill;
      actx.fill();

      actx.strokeStyle = s.color;
      actx.lineWidth = 2;
      actx.stroke();
    }

    // Velocity curve overlay
    actx.lineWidth = 2.5;
    actx.strokeStyle = '#444';
    actx.beginPath();
    actx.moveTo(tToX(f.x0, f.x1, 0), vToY(f.y0, f.y1, velocityAt(0)));
    for (const s of segments) {
      if (s.type === 'jump') {
        if (t >= s.t0) {
          actx.stroke();
          const xJ = tToX(f.x0, f.x1, s.t0);
          const yB = vToY(f.y0, f.y1, s.v0);
          const yA = vToY(f.y0, f.y1, s.v1);
          actx.setLineDash([3,3]);
          actx.strokeStyle = '#888';
          actx.beginPath();
          actx.moveTo(xJ, yB); actx.lineTo(xJ, yA); actx.stroke();
          actx.setLineDash([]);
          actx.beginPath();
          actx.strokeStyle = '#444';
          actx.lineWidth = 2.5;
          actx.moveTo(xJ, yA);
        }
        continue;
      }
      const segEnd = Math.min(s.t1, t);
      if (segEnd > s.t0) {
        const x0 = tToX(f.x0, f.x1, s.t0);
        const y0v = vToY(f.y0, f.y1, s.v0);
        const xE = tToX(f.x0, f.x1, segEnd);
        const vEnd = s.type === 'const'
          ? s.v0
          : s.v0 + (s.v1 - s.v0) * ((segEnd - s.t0) / (s.t1 - s.t0));
        const yEv = vToY(f.y0, f.y1, vEnd);
        actx.lineTo(x0, y0v);
        actx.lineTo(xE, yEv);
      }
    }
    actx.stroke();

    // Time cursor
    const xNow = tToX(f.x0, f.x1, t);
    actx.beginPath();
    actx.moveTo
    actx.moveTo(xNow, f.y0);
    actx.lineTo(xNow, f.y1);
    actx.strokeStyle = 'rgba(0,0,0,0.2)';
    actx.lineWidth = 2;
    actx.stroke();

    const S = cumulativeDisplacement(t);
    areaReadout.textContent = `t = ${t.toFixed(2)} s, total displacement = ${S.toFixed(2)} m`;

    if (elapsed < tMax) {
      requestAnimationFrame(frame);
    } else {
      const Sfinal = cumulativeDisplacement(tMax);
      actx.font = 'bold 14px Arial';
      actx.fillStyle = '#000';
      actx.fillText(`Pierre Marie Curie Physics09 Class`, f.x0 + 12, f.y1 + 18);
      actx.fillStyle = '#d32f2f';
      actx.fillText(`Total displacement = ${Sfinal.toFixed(2)} m`, f.x0 + 12, f.y1 + 38);

      let yText = f.y1 + 60;
      actx.fillStyle = '#444';
      for (const s of segments) {
        if (s.type === 'jump') continue;
        const A = signedAreaOfSegmentUpTo(s, s.t1);
        actx.fillText(`${s.name}: ${A.toFixed(2)} m`, f.x0 + 12, yText);
        yText += 18;
      }
    }
  }
  frame();
}

startAreasBtn.addEventListener('click', animateAreas);

// Shared helpers
function tToX(x0, x1, t) {
  return x0 + (t / tMax) * (x1 - x0);
}
function vToY(y0, y1, v) {
  const frac = (Math.max(vMin, Math.min(v, vMax)) - vMin) / (vMax - vMin);
  return y0 - frac * (y0 - y1);
}
</script>

</body>
</html>
